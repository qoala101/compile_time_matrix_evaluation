#define CTME_DEBUG

#include <gtest/gtest-message.h>
#include <gtest/gtest-test-part.h>

#include <cstdint>
#include <vector>

#include "ctme_debug_logger.h"
#include "ctme_evaluate_cell.h"
#include "ctme_evaluate_to_vector.h"
#include "ctme_mat.h"
#include "ctme_mat_product.h"
#include "gtest/gtest_pred_impl.h"

namespace {
TEST(DebugLogger, Ability) {
  // clang-format off
  const auto m0 = std::vector<std::vector<int>>{std::vector<int>
      {11, 12, 13},
      {14, 15, 16}};

  const auto m1 = std::vector<std::vector<float>>{std::vector<float>
      {21.1, 22.1},
      {23.1, 24.1},
      {25.1, 26.1}};

  const auto m2 = std::vector<std::vector<double>>{std::vector<double>
      {31.1, 32.1, 33.1, 34.1},
      {35.1, 36.1, 37.1, 38.1}};

  const auto m3 = std::vector<std::vector<int64_t>>{std::vector<int64_t>
      {1, 0, 0, 0},
      {0, 1, 0, 0},
      {0, 0, 1, 0},
      {0, 0, 0, 1}};
  // clang-format on

  ctme::debug::Logger::Instance().RegisterMatName(m0, "m1");
  ctme::debug::Logger::Instance().RegisterMatName(m1, "m2");
  ctme::debug::Logger::Instance().RegisterMatName(m2, "m3");
  ctme::debug::Logger::Instance().RegisterMatName(m3, "m4");

  testing::internal::CaptureStdout();
  const auto cell =
      ctme::EvaluateCell<0, 0>(ctme::Mat<2, 3>{} * ctme::Mat<3, 2>{} *
                                   ctme::Mat<2, 4>{} * ctme::Mat<4, 4>{},
                               m0, m1, m2, m3);
  EXPECT_EQ(testing::internal::GetCapturedStdout(), R"(

Evaluating cell (0, 0):
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][3] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][3] * m4[3][0] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][2] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][2] * m4[2][0] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][1] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][1] * m4[1][0] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][0] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][0] * m4[0][0])");

  testing::internal::CaptureStdout();
  const auto vector =
      ctme::EvaluateToVector(ctme::Mat<2, 3>{} * ctme::Mat<3, 2>{} *
                                 ctme::Mat<2, 4>{} * ctme::Mat<4, 4>{},
                             m0, m1, m2, m3);
  EXPECT_EQ(testing::internal::GetCapturedStdout(), R"(

Evaluating cell (1, 3):
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][3] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][3] * m4[3][3] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][2] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][2] * m4[2][3] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][1] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][1] * m4[1][3] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][0] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][0] * m4[0][3]

Evaluating cell (1, 2):
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][3] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][3] * m4[3][2] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][2] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][2] * m4[2][2] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][1] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][1] * m4[1][2] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][0] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][0] * m4[0][2]

Evaluating cell (1, 1):
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][3] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][3] * m4[3][1] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][2] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][2] * m4[2][1] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][1] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][1] * m4[1][1] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][0] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][0] * m4[0][1]

Evaluating cell (1, 0):
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][3] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][3] * m4[3][0] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][2] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][2] * m4[2][0] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][1] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][1] * m4[1][0] +
m1[1][2] * m2[2][1] +
m1[1][1] * m2[1][1] +
m1[1][0] * m2[0][1] * m3[1][0] +
m1[1][2] * m2[2][0] +
m1[1][1] * m2[1][0] +
m1[1][0] * m2[0][0] * m3[0][0] * m4[0][0]

Evaluating cell (0, 3):
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][3] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][3] * m4[3][3] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][2] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][2] * m4[2][3] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][1] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][1] * m4[1][3] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][0] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][0] * m4[0][3]

Evaluating cell (0, 2):
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][3] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][3] * m4[3][2] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][2] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][2] * m4[2][2] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][1] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][1] * m4[1][2] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][0] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][0] * m4[0][2]

Evaluating cell (0, 1):
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][3] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][3] * m4[3][1] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][2] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][2] * m4[2][1] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][1] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][1] * m4[1][1] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][0] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][0] * m4[0][1]

Evaluating cell (0, 0):
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][3] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][3] * m4[3][0] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][2] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][2] * m4[2][0] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][1] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][1] * m4[1][0] +
m1[0][2] * m2[2][1] +
m1[0][1] * m2[1][1] +
m1[0][0] * m2[0][1] * m3[1][0] +
m1[0][2] * m2[2][0] +
m1[0][1] * m2[1][0] +
m1[0][0] * m2[0][0] * m3[0][0] * m4[0][0])");
}
}  // namespace

#undef CTME_DEBUG